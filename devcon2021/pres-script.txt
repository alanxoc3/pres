Alright, thanks x.

As x mentioned, I'm alan. I'm a Software Engineer here at Clearwater Analytics.
I've been using Linux for about 10 years now. And I'm obsessed with the command
line.

Now this presentation will be a little different than what you may be used to,
because everything you see on this screen will be completely contained within
a terminal emulator.

And when I say everything, I mean everything.

<title>

the command line

What you see here is probably the coolest part of the presentation, so i'll
let you soak it in for a minute while i briefly explain my setup.

the terminal emulator i'm using is called alacritty, the bottom bar you see is
from me running tmux locally on my laptop. the top bar is from me running tmux
remotely through ssh on an arch linux machine. and the powerpoint-like
presentation software i'm using is called lookatme.

i'm going to cover a lot of content in the next 40 minutes. if you feel lost,
we'll have a few questions at the end, you can rewatch this online, and i also
have a keylogger running at the bottom right of the screen so i'll try not to
type any sensitive passwords for you.

by the end of this presentation i hope you feel motivated to use the
commandline a bit more than you currently do as part of your daily workflow.

from here i'll go over some of the history of the terminal emulator and the
command line, then you can watch me run a bunch of random commands. if we're
lucky, nothing will go wrong. so let's get started.

<history of terminal emulator>

the terminal emulator has a pretty neat history and actually starts with the
invention of the electric telegraph. for the telegraph to work, you need a
sender and receiver, a wire between the two, and some sort of binary encoding
to send signals to the other person. in many early implementations of the
telegraph, both the sender and receiver will memorize that binary encoding to
communicate with each other.

alongside the growing popularity of the telegraph, various forms of typewriters
were invented, the most notable one being the sholes and glidden typewriter.
this typewriter was the first typewriter to use the qwerty layout and because
it was a commercial success, most people use the qwerty layout today.

now that these two great innovations exist in the late 1800s or early 1900s,
people started thinking, "hey, what if we combine the electric telegraph with
the typewriter", and that's exactly what happened. we can give the sender and
receiver typewriter-like devices called teleprinters. the sender can type out a
message, verify he typed the correct thing on his piece of paper, and press
send. the receiver can then watch his teleprinter type out the message the
sender sent and reply to that message if he wants.

later on, computers started to get popular around the 1950s. now that we have
these computers, instead of using a teleprinter to communicate with another
person, what if you used a teleprinter to communicate with a computer? again,
that's exactly what happened, though not until interactive computer use was
more cost efficient with the development of time sharing.

quickly after computer integration with teleprinters started to gain
popularity, computer terminals were created and had a bunch of nice features
over teleprinters including, not being loud, displaying characters instantly,
being able to modify characters anywhere on a screen, and of course these
computer terminals made the world greener by using less paper.

finally in our world of 4k monitors, we run programs called "terminal
emulators" to imitate these earlier "computer terminals". windows, mac, and linux all
have default terminal emulators. kitty, terminator, alacritty, and xterm are a
few of the many others.

<history of command line>

when i mention "the command line", i am specifically referring to the unix
command line. i don't know anything about powershell, so don't ask me. the
history of the unix command line is heavily tied to the history of the unix
operating system. the story of unix starts in the 1960s and 70s with a group of researchers
at bell labs who were working on an operating system called multics. they became
frustrated with the complexity of multics, so they abandoned that project to
work on something smaller, which later became unix. unix began to be
distributed to universities throughout the 70s and 80s. macos and linux later
built off unix in the 90s. and the rest is history.

one of the reasons unix and the commandline have been so successful is because
of the unix philosophy. There are many definitions of the "Unix Philosophy",
the one i like most is attributed to Douglas McIlroy he was the creator of the
unix pipe and one of those researchers at bell labs in the 60s and 70s. he
said,

"this is the unix philosophy: write programs that do one thing and do it well.
write programs to work together. write programs to handle text streams, because
that is a universal interface."

alright, the history lesson is over, so let's do some things in the command
line!

in unix, the shell is a program that makes it easy to run other programs
interactively. unix has had a shell or sh command a since version 1. it was
originally known as the "thompson shell", but later rewritten by stephen bourne
in version 7 and is now known as the bourne shell. the bourne shell is
installed on almost every unix based operating system today, including the one
i'm presenting on, so let's check it out.

i've split my screen with a shell running at the bottom. if i want to run the
bourne shell, i can type sh. the bash shell was an attempt to rewrite and
improve the bourne shell. and there are many other shells out there you can
install. zsh is the shell I use, it's the first one you saw and the default on
my system. fish is a popular one i installed
for this presentation, and nu is a new one i heard of recently, but haven't
tried. you can leave most shells by using the built in "exit" command or by
sending the end of file character with ctrl-d. you can usually clear the screen
with the "clear" command or ctrl-l.

when you use the shell, you are always located within a directory. to see
which directory that is, type pwd or print working directory. to change your
directory, you can type cd followed by the directory name. and pwd to make sure
that worked. cd usually has some nice shortcuts. for example, if you want to go
to the previous directory you were at, try cd followed by a dash.

we can view the files in a directory with "ls". "cd .." will take us up a
directory. we can use the "find" command to list all the files in this
directory recursively. you can see that it printed out a bunch of stuff. a lot
of these files are from the hidden git directory. the "fd" command is a modern
replacement to the find command that you can install. fd by default does not show
hidden files and it gives us nice colors.

just like you can touch your computer screen, you can touch files too with the
touch command. this causes the last edit timestamp of that file to update. ls
-l will show those timestamps. if i touch a file and run ls -l again, you can
see that the timestamp has been updated. touch has a nice side effect of
creating an empty file if the file does not exist.

use cp to copy files. use mv to rename files. or move them. and you can delete
files with rm.

next up, "echo", which just prints what you tell it to. we can redirect this to
a file and see that there is no output. but there is now a file named says. cat
can be used to print the contents of a file. cat says, enter, "meow". cat actually
stands for concatenate, so if you pass multiple files to it, it will print both
those files out. cat says what, meow me-ow.

```
echo testing
echo meow > says
echo me-ow > what
```

the pipe operator can be used to pass the output of one program to the input of
another. if i type echo hello, it prints hello. if i pipe that to cat, it still
prints hello, so that's not very interesting.

but if i type fd to show all the files, then pass the output to head and ask
for only the first two lines, it shows me only the first two lines. i can do
the same thing with tail and only show the last two lines.

the yes command prints the same thing infinitely until you stop it with ctrl-c.
if i pipe the output of this command to cat, it still does the same thing, so
it's still

---

intro & history is under 7 minutes.

Oh, what if the "one thing and do it well"

What if I divided my presentation into parts of the Unix Philosophy?

Write programs that do one thing and do it well:
- How many times have you had to handle authentication in your program?
- How many different libraries are there for authentication?
- Wouldn't it be nice if every program on your computer didn't have its own file -> open menu?
- What if reading a blog only contained text?

Write programs to work together: (work with robots)
- Wouldn't it be nice if you didn't have to write everything in one language?
- Automation likes text streams.
- Text streams are lower latency.

Write programs to handle text streams: (work with humans
- man pages
- help commands
- good user interfaces
- Text streams are both human and machine readable.

programs that work well with other programs
programs that work well with humans

are there frameworks that let computers work well with GUIs? Yes. Are those
frameworks massively complex? Also yes.

i'm preparing for this presentation and want to ensure what i plan on saying is
correct. i could just make some selections and execute a command on each one.

| g++ -x c++ -
in kak: which <cmd> | zsh (shows if things are actually executables or not.)

ps $$ | python3 -c 'import sys; print(sys.stdin.read().split()[-1])' | xargs
