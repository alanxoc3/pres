alright, thanks x, and thanks to everyone here for listening into my
presentation. i'm alan. i've been working here at clearwater analytics for
about 3 years now. i've been using linux for about 10 years, and i'm obsessed
with the command line.

this presentation will be a little different than what you may be used to
because the entire presentation will be completely contained within a command
line type environment. and when i say everything, i mean everything. including
the presentation sofware i use and gifs.

the commandline is the title of my presentation. i'm going to be covering a lot
of content in the next 40 minutes or so. if you feel lost, we'll have a few
questions at the end, you can always rewatch this presentation online, and i
have a keylogger running at the bottom right of the screen.

by the end of this presentation i hope you're motivated to use the commandline
a little bit more than you currently do as part of your daily workflow.

from here, i'll give you a quick history lesson, then you can watch me run a
bunch of random commands. if we're lucky, nothing will go wrong, so let's get
started.

for the hardware related history of the command line, i'd argue that it all
begins with the invention of teleprinters.

a teleprinter was a typewriter like device, popular in the early 1900s, that
could both send and receive telegraph messages. for example a person could type
up a message on a teleprinter and when they send it, the receiving teleprinter
would automatically type that same message out to a piece of paper.

computers emerged around the 1950s. as computers improved, many people switched
from using punch cards to using teleprinters to interact with computers.
computer terminals later came along with a few benefits to teleprinters
including, being faster, being quieter, and of course making the world greener
by using less paper. computer terminals improved in the 70s with colors and
a movable cursor. guis started taking over in the 80s. and today we use
terminal emulator programs to access the command line.

for the software related history of the command line, i'd argue that it all
begins with the implementation of time sharing.

time sharing made it possible for multiple users to use one computer at the
same time by having the computer constantly switch between tasks. this means
that expensive computers were now both easier to use and more accessible.

in 1964 a large group of researchers spanning multiple institutions started
working on a revolutionary operating system called multics. some of those
researchers from at&t's bell labs abandoned the multics project because they
felt like the project was overly complex. and they started a much smaller
operating system project called unix. the command line we have today comes from
unix and many of the tools that were available to early versions of unix are
still available and useful today.

unix was distributed to various institutions throughout the 70s and 80s. linux
started becoming popular in the 90s. and today, almost anyone in the world can
access a unix command line if they really want to.

with that said, let's start actually using the command line. beginning with the
shell.

the shell is a program that makes it easy to run other programs interactively.
i split my screen and i will run the echo command which just prints what i tell
it to. sh is the shell that was distributed with unix. bash tried to improve
sh. zsh is a modern shell that i use. fish is a modern shell that i don't use
and there are many other shells out there.

to exit a shell, type exit, or you can usually send the end-of-file character
with ctrl-d. clear will clear your screen. ctrl-l usually clears your screen
too. to see the directory you're currently in, run pwd. cd can change your
directory. cd followed by a dash can bring you to the directory you were
previously at. you can see that these two directories are indeed the same.
cd .. will bring you to the parent directory. ls can show you all the files and
folders in your directory. and now we'll now cd back into the directory we were
originally at.

looking at this directory, you can see there are some files, so let's learn
about a few command line editors. ed was the editor distributed with unix. you
can pass a filename to ed and it will allow you to edit that file by running
some commands. i don't actually know how to use ed, i only know that ed was
notoriously difficult to use, which prompted someone to write em or an editor
for mortals.

after em. ex and vi came along. as you can see, vi is a full screen editor.
while ed would have been compatible with teleprinters, vi would have needed a
computer terminal in order to run. vim tries to improve vi with better
defaults, a highlighting mode, as well as its own scripting language.

nano is a beginner friendly editor with sane defaults as well as a list of
shortcuts at the bottom, you can use the arrow keys to move and there is a list
of keyboard shortcuts at the bottom. emacs is an editor with terrible defaults,
but is extremely configurable. neovim is a modern fork of vim that comes with a
built in lua interpreter, tresitter parser for advanced syntax highlighting,
and language server protocol implementation for ide-like features. kakoune is a
less-known vim spinoff and is the editor that i actually use. it changes some
of the basic keybindings that comes with vim and works really well with
multiple cursors. for example, i can select the whole file, prefix every line
with a dash, join all the lines together, and remove all spaces.

back to the command line, i think we're ready to go over the unix pipe.
starting with the redirection operator, we can take the output of a command and
redirect it into a file. let's first look at the files in this directory. then
echo hello, you can see the output is hello. followed by the redirection
operator and a file name, you can see it created a new file. we'll use the cat
command to see what's inside that file and it looks like it matches the echo
command we ran earlier.

the pipe operator is used to take the output of one command and make it the
input of another command.

echo hello prints hello, if we pipe that to the cat command, it doesn't do
anything interesting, because cat just displays what it's given.

so let's try something else. i made my shell full screen temporarily. let's try
catting this text file. as you can see, the output of this cat command is a
cat. we can pipe that into the head command which by default gives you the top
10 lines of a file or the cat's head. likewise with the tail command, we can
get the bottom 10 lines, which is, you guessed it, the cat's tail.

looking at this cat more closely, the scientist in me wants to ask which
character occurs the most often in this cat picture. so let's use the unix pipe
to figure that out.

the first thing i would do is get each character on it's own line, because a
lot of commands work better at a line level. we can use sed to achieve this.
the dash e is for extended regular expressions. we want to substitute every
character on a line with whatever that character is followed by a new line. and
do this globally for every match on the line.

if you ask me, it looks like our cat is having a bad day, but this is all in
the name science, so let's continue.

next, i'd probably get rid of all the empty lines, so let's use awk to do that.
awk a command that comes with a simple programming language. first you filter
each line with a regular expression. then you can run a command on that filter.
i'd like every line that has at least 1 character and that character is not a
space. and i'd like to print that line. looking through the output, i don't see
any blank lines, so that's a good sign. next, sorting the output is probably a
good idea. the uniq command can be used to remove duplicate consecutive lines.
we can now see all the different characters that make up the cat. the -c option
gives us the number of times each line was printed. we can sort that again,
but we want a numeric sort. and as you can see, the most common character in
that cat is a period.

alright, enough talking about cats. let's switch the subject to something a
little more human and talk about man. man stands manual. you may have heard the
saying, "a dog is a man's best friend". while that is indeed true, man is a
cat's best friend. he knows everything about a cat, the description of a cat.
the different parameters you can pass to the cat, who created the cat, and so
on.

there are a lot of things you have to keep track of when using the command
line. if you forget something, you can open up the manual page to refresh your
memory. there are other ways to view documentation in the command line though.
many commands implement a `--help`. so you can try that if you want. tldr is a
cool project on github that is meant to be your goto resource before you open
up a man page. looking at the output, it shows me a quick description of the
command as well as some of the most common ways to use the command according to
the tldr community.

you can also have your own self documentation. there are many ways to do this.
i personally do this in the form of aliases. aliases provide a way to shorten
commands. to create an alias, use the alias command. this alias will look like
'hi=echo hello'. now every time i type hi, it will run the command 'echo
hello'. 'alias hi' will show me what hi is. i actually use the alias command
often enough that i have an alias for the alias command. i have another alias
for editing aliases. when i type ea, you can see a bunch of my aliases.

you may have noticed that my "ls" command is really pretty, that's because it's
actually an alias for another program called exa. exa is an ls clone with a
knowledge of git and some other things like a tree view.

(cd ~/repos/pres/)
a ls
/bin/ls
exa
a lst
lst

bat is like cat, but comes with syntax highlighting.

cat main.cpp
bat main.cpp

fd is a find clone, but better.

find .
fd
fd -t f
fd -t d

rg is a grep clone, but better.

fd | rg txt
rg echo

and there are many other improvements
out there, including a really popular one called fzf.

fzf is a fuzzy filter.

fd -t f
fd -t f | fzf
bat $(fd -t f | fzf)
bat <ctrl-t>
<alt-z> [bat] main.cpp
<alt-z> [rg kak] Software

lots more you can do with fzf. if we have extra time, we could go over more.

tmux is a window manager and multiplexer. you've been watching me use tmux
throughout this entire presentation. the bottom bar comes from me running tmux
locally. the top bar comes from me running tmux remotely though ssh on an arch
linux machine. tmux being a window manager, means you can make windows full
screen and create new workspaces like many modern gui-based window managers.
tmux being a multiplexer means that you can lose connection with tmux, and not
lose any of your work. another cool thing about tmux is that it's great for
pair programming.

you've also been watching me use lookatme this whole time. i first heard about
lookatme by watching some vimconf presentations. lookatme is just a markdown
presentation tool. you can see that my presentation is actually a markdown
file. when i run lookatme, it starts the presentation.

lookatme ./README.md

asciinema is an easy way to record videos in the commandline. i've used
asciinema as part of opening bug reports to open source projects multiple times
in the past.

asciinema rec
cat asciiart.txt | cowsay -n
exit
<ctrl-z> [tmux] /tmp/asciinemafile

ranger is terminal ui for navigating files. it's more similar to "finder" on
mac, or windows explorer. i don't use it much, but it's especially nice for
navigating file systems you're less familiar with.

ranger

pass is a cli based password manager i use. it uses gpg to encrypt files that
contain passwords.

man pass

there are a few cli based web browsers. i'd consider w3m to be the best one at
the moment, though it doesn't support javascript. but that's ok, because if i'm
using the command line for everything so far, i probably don't like javascript.

w3m ddg.gg
a ddg
ddg hello world
ddg \!g hello world

there are other internets within the internet. one is called gemini. instead of
websites, gemini has capsules that host mostly plain-text static content.
amfora is one of many browsers for these gemini capsules. here is my own gemini
capsule. and here is a capsule that shows updates from other capsules.

a amx
amx
a ama
ama

mpv is the best media player i've ever come across, and it's designed as a cli
tool. i use mpv to play webradios, which are usually endless ".ogg" files.

a chiptune
a tilderadio
a anonradio

you can use mpv to play gifs.

./pres title
./pres teleprinter

and you can even use mpv to play youtube videos.

./pres youtube

in case you haven't noticed yet, you've all been rick rolled.

himalaya is a pretty new cli based email client you can find on github.

himalaya

irc is the chat service before the modern internet. ii is a simple, yet
ingenious program that uses linux fifos (named pipes) to interface with irc
servers. this is a beautiful and unique example of the unix philosophy in
action.

irc-run
irc-feed
cd ~/irc/libera/#devcon2021
echo hello world > in

unfortunately, that's all i have time for. there's a lot of fun stuff out there
when it comes to the command line. so i hope you've learned something and i
hope i converted some of you over to the dark side.

you can find this presentation markdown file at git.io/devcon2021. and i'll
open up the remaining time for questions.
