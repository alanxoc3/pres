Alright, thanks x.

As x mentioned, I'm alan. I'm a Software Engineer here at Clearwater Analytics.
I've been using Linux for about 10 years now. And I'm obsessed with the command
line.

Now this presentation will be a little different than what you may be used to,
because everything you see on this screen will be completely contained within
a terminal emulator.

And when I say everything, I mean everything.

<title>

the command line

What you see here is probably the coolest part of the presentation, so i'll
let you soak it in for a minute while i briefly explain my setup.

the terminal emulator i'm using is called alacritty, the bottom bar you see is
from me running tmux locally on my laptop. the top bar is from me running tmux
remotely through ssh on an arch linux machine. and the powerpoint-like
presentation software i'm using is called lookatme.

i'm going to cover a lot of content in the next 40 minutes. if you feel lost,
we'll have a few questions at the end, you can rewatch this online, and i also
have a keylogger running at the bottom right of the screen so i'll try not to
type any sensitive passwords for you.

by the end of this presentation i hope you feel motivated to use the
commandline a bit more than you currently do as part of your daily workflow.

from here i'll go over some of the history of the terminal emulator and the
command line, then you can watch me run a bunch of random commands. if we're
lucky, nothing will go wrong. so let's get started.

<history of terminal emulator>

the terminal emulator has a pretty neat history and actually starts with the
invention of the electric telegraph. for the telegraph to work, you need a
sender and receiver, a wire between the two, and some sort of binary encoding
to send signals to the other person. in many early implementations of the
telegraph, both the sender and receiver will memorize that binary encoding to
communicate with each other.

alongside the growing popularity of the telegraph, various forms of typewriters
were invented, the most notable one being the sholes and glidden typewriter.
this typewriter was the first typewriter to use the qwerty layout and because
it was a commercial success, most people use the qwerty layout today.

now that these two great innovations exist in the late 1800s or early 1900s,
people started thinking, "hey, what if we combine the electric telegraph with
the typewriter", and that's exactly what happened. we can give the sender and
receiver typewriter-like devices called teleprinters. the sender can type out a
message, verify he typed the correct thing on his piece of paper, and press
send. the receiver can then watch his teleprinter type out the message the
sender sent and reply to that message if he wants.

later on, computers started to get popular around the 1950s. now that we have
these computers, instead of using a teleprinter to communicate with another
person, what if you used a teleprinter to communicate with a computer? again,
that's exactly what happened, though not until interactive computer use was
more cost efficient with the development of time sharing.

quickly after computer integration with teleprinters started to gain
popularity, computer terminals were created and had a bunch of nice features
over teleprinters including, not being loud, displaying characters instantly,
being able to modify characters anywhere on a screen, and of course these
computer terminals made the world greener by using less paper.

finally in our world of 4k monitors, we run programs called "terminal
emulators" to imitate these earlier "computer terminals". windows, mac, and linux all
have default terminal emulators. kitty, terminator, alacritty, and xterm are a
few of the many others.

<history of command line>

when i mention "the command line", i am specifically referring to the unix
command line. i don't know anything about powershell, so don't ask me. the
history of the unix command line is heavily tied to the history of the unix
operating system. the story of unix starts in the 1960s and 70s with a group of researchers
at bell labs who were working on an operating system called multics. they became
frustrated with the complexity of multics, so they abandoned that project to
work on something smaller, which later became unix. unix began to be
distributed to universities throughout the 70s and 80s. macos and linux later
built off unix in the 90s. and the rest is history.

one of the reasons unix and the commandline have been so successful is because
of the unix philosophy. There are many definitions of the "Unix Philosophy",
the one i like most is attributed to Douglas McIlroy he was the creator of the
unix pipe and one of those researchers at bell labs in the 60s and 70s. he
said,

"this is the unix philosophy: write programs that do one thing and do it well.
write programs to work together. write programs to handle text streams, because
that is a universal interface."

alright, the history lesson is over, so let's do some things in the command
line!

---

intro & history is under 7 minutes.

Oh, what if the "one thing and do it well"

What if I divided my presentation into parts of the Unix Philosophy?

Write programs that do one thing and do it well:
- How many times have you had to handle authentication in your program?
- How many different libraries are there for authentication?
- Wouldn't it be nice if every program on your computer didn't have its own file -> open menu?
- What if reading a blog only contained text?

Write programs to work together: (work with robots)
- Wouldn't it be nice if you didn't have to write everything in one language?
- Automation likes text streams.
- Text streams are lower latency.

Write programs to handle text streams: (work with humans
- man pages
- help commands
- good user interfaces
- Text streams are both human and machine readable.

programs that work well with other programs
programs that work well with humans

are there frameworks that let computers work well with GUIs? Yes. Are those
frameworks massively complex? Also yes.

i'm preparing for this presentation and want to ensure what i plan on saying is
correct. i could just make some selections and execute a command on each one.

| g++ -x c++ -
in kak: which <cmd> | zsh (shows if things are actually executables or not.)

ps $$ | python3 -c 'import sys; print(sys.stdin.read().split()[-1])' | xargs
